#!/usr/bin/python3

# $lic$
# Copyright (C) 2019-2022 by Daniel Sanchez
#
# This file is part of the Minispec compiler and toolset.
#
# Minispec is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2.
#
# Minispec is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.

import sys

# Usage: python filter_stdcell.py < input.lib
origLib = sys.stdin.read()

pos = 0
breaks = []
while True:
    # NOTE: Completely tied to the indentation of the original file; extra space avoids matching comment.
    cellStart = origLib.find("  cell (", pos)
    if cellStart == -1:
        break
    cellClosePar = origLib.find(")", cellStart)
    cellName = origLib[cellStart+8:cellClosePar]
    prevBlockEnd = origLib.rfind("}", 0, cellStart)
    assert prevBlockEnd != -1
    blockStart = prevBlockEnd + 2
    breaks.append((cellName, blockStart))
    pos = cellClosePar
breaks.append(("__END__", origLib.rfind("}")))

def basicFilter(cellName):
    (cellClass, _, cellStrength) = cellName.partition("_")
    if cellClass in ["INV", "NAND2", "NOR2", "BUF", "DFF"] and cellStrength == "X1":
        return cellClass
    return None

def multisizeFilter(cellName):
    for prefix in ["AND", "OR", "NAND", "NOR", "XOR", "XNOR", "INV", "BUF", "DFF_"]:
        if cellName.startswith(prefix):
            return cellName
    return None

def extendedFilter(cellName):
    (cellClass, _, cellStrength) = cellName.partition("_")
    if multisizeFilter(cellName) and cellStrength == "X1":
        return cellClass

for (outName, filter) in [("basic.lib", basicFilter), ("extended.lib", extendedFilter), ("multisize.lib", multisizeFilter)]:
    output = [origLib[0:breaks[0][1]]]
    for i in range(len(breaks) - 1):
        (cellName, startPos) = breaks[i]
        endPos = breaks[i+1][1]
        outCell = filter(cellName)
        if outCell:
            output.append(origLib[startPos:endPos].replace(cellName, outCell))
    output.append(origLib[breaks[-1][1]:])
    print("Saving %d/%d cells to %s" % (len(output) - 2, len(breaks) - 2, outName))
    f = open(outName, "w")
    print("/* Autogenerated subset of %d cells from library below -- DO NOT EDIT MANUALLY */" % (len(output) - 2,), file=f)
    print("".join(output), file=f)
    f.close()
